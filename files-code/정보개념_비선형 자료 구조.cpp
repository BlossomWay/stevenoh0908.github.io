///정보개념_비선형 자료 구조
/*
# 비선형 자료 구조_트리(Tree)

> 트리(Tree) : 개론
~ 영어로, Tree, 즉 나무의 구조를 본떠(거꾸로 뒤집어) 만든 추상화 데이터 자료형이다.
~ 가계도의 형태를 하고 있는 비선형 추상화 자료 구조라고 생각해도 무방하다.

> 트리(Tree) : 소개
~ 노드/정점 : 자료를 나타내는 원
~ 링크/간선 : 자료 사이의 관계를 나타낸다. (양방 연결이나 단방 연결)
~ 기본적으로 트리와 그래프의 구분은 순환의 유무로서 한다
~ 비선형 자료 구조: 자료들 사이에 하나 이상의 연결 관계를 가질 수 있는 자료 구조
~~ 순환이 없는 위계 관계: 트리
~~ 순환이 있거나 부모가 둘 이상이 있는 연결관계: 그래프

> 트리(Tree): 용어 - 가계도를 생각하라!
~ 자식노드: 노드의 하위 노드(들)
~ 부모노드: 노드의 상위 노드
~ 형제노드: 동일 부모노드를 가진 자식노드
~ 루트노드: 최상위 부모노드
~ 단말노드: 자식이 없는 가장 끝 노드
~ 깊이: 루트 노드로부터 그 위치까지 경로 길이
~ 높이: 루트 노드로부터 가장 깊은 노드까지의 경로의 길이
~ 차수: 그 노드의 자식 노드의 개수

> 2진트리
~ 2진트리: 트리의 모든 노드의 차수가 2이하인 트리
~ 완전 2진 트리: 트리의 최하층을 제외한 모든 노드가 채워진 2진 트리 최하층의 노드들은 LEFT->RIGHT로 순서대로 채워진다.
                 중간에 비면 안되고, 최하층만 빌 수 있다(왼쪽부터 채워지는 최하층)

> 완전 2진 트리의 1차원 배열로의 저장
~ 완전 2진 트리에서 TOP->BOTTOM, LEFT->RIGHT 순으로 넘버링을 해서 배열에 넣으면(단, 0은 비운다(0에 2를 곱해도 0)) 대응시킬 수 있다. (교과서 135p)
~ 부모 노드의 왼쪽 자식 노드는 부모노드 인덱스*2
~ 부모 노드의 오른쪽 자식 노드는 부모노드 인덱스*2+1
~ 자식 노드의 부모 노드는 자식노드 인덱스/2

> 완전 2진 트리의 최대 노드 개수
~ 완전 2진 트리에서 최하층까지 꽉 찼을 때, 트리의 노드의 개수를 완전 2진트리의 최대 노드 개수라고 한다.
~ 높이가 n인 완전 2진 트리의 최대 노드 개수는 2^(n+1)-1 개. 1+2+4+8+...이니까.

> 번외: 비트 쉬프트 연산자(<<. >>)
~ 좌측 쉬프트 연산(<<): 비트를 왼쪽으로 1칸, 왼쪽 오버는 버리고 오른쪽은 모두 0으로 채운다. -> *2의 효과가 난다.
~ 우측 쉬프트 연산(>>): 비트를 오른쪽으로 1칸, 오른쪽 오버는 버리고, 인쪽은 모두 0으로 채운다. -> /2의 효과가 난다.
~ 좌/우측 쉬프트 연산은 2^n의 꼴 연산의 표현에 도움이 된다.
*/

//완전 2진 트리에 대한 1차원 배열로의 저장
/*
#include <iostream>
using namespace std;

int main() {
    int Tree[1<<2] = {0}; //깊이가 2인 완전 2진 트리의 선언
    int n;

    //완전 2진 트리를 1차원 배열에 대응시킨 것에 INPUT
    cin >> n;
    for(int i=1;i<n;i++) {
        cin >> Tree[i];
    }

    //3번 노드의 부모 노드, 3번 노드, 자식 노드(왼쪽 자식 노드, 오른쪽 자식 노드 순) 출력
    cout << "3번 노드의 부모 노드 : " << Tree[3/2] << endl; //3번 노드의 부모 노드는 1번(루트)노드
    cout << "3번 노드 : " << Tree[3] << endl; //3번 노드
    cout << "3번 노드의 왼쪽 자식 노드 : " << Tree[3*2] << endl; //3번 노드의 왼쪽자식 노드는 6번 노드
    cout << "3번 노드의 오른쪽 자식 노드 : " << Tree[3*2+1] << endl; //3번 노드의 오른쪽 자식 노드는 7번 노드

    return 0;
}
*/
/*
> 히프(Heap)
~ 최대 히프는 부모가 항상 자식보다 큰 값을 가진다.
~ 최소 히프는 자식이 항상 부모보다 큰 값을 가진다.
~ 따라서 히프에서 확실한 한가지는 -> 힙에서 가장 작은/큰 데이터를 가지는 노드는 루트 노드이거나, 말단 노드이다.

> 히프(Heap)를 만드는 방법(최대 히프를 만드는 기준)
~ 1. 히프의 최고 깊이, 최우측(하단 최말단)에 새 노드를 추가한다. 물론 이때 히프는 완전 이진 트리를 유지해야 한다.
~ 2. 삽입한 노드를 부모 노드와 비교한다. 삽입한 노드가 부모 노드보다 작다면 놔두고, 크다면 부모와 위치를 바꾼다. 그리고 다시 그 부모 노드와 비교해서 그 위치를 확정한다.

> 히프 탐색
~ 히프의 탐색에서, 히프에 대응하는 1차원 배열은 정렬 기준이 1차원 배열 자체로 내림차순이나 오름차순이 아니므로, 2진 탐색을 수행할 수 없다.

> 히프 정렬
1. n개의 노드에 대한 완전 2진 트리를 구성한다(그냥 바로 배열에 쳐 받는다)
2. 정렬되지 않은 원소를 바탕으로 최대 힙을 구성한다. (최대 힙에서 루트 노드는 그 힙에서 최대인 원소를 가지고 있음) -> 최대 힙의 구성은 부모 노드로 올라가면서 비교해서 한다.
3. 루트 노드와 가장 오른쪽 단말 노드의 값을 교환한다.
4. 마지막 배열 원소를 제외하고, 나머지로 최대 힙을 구성해는 2, 3을 반복한다.
*/

//2진 히프 정렬 ** 코드 오류 있음. 수정할 것!

#include <iostream>
using namespace std;

int Heap[1000];

int main() {
    int n, foo;
    cin >> n;
    for(int i=1;i<=n;i++) {
        cin >> Heap[i];
        int j=i;
        while(1) {
            if(Heap[j/2] < Heap[j]) {
                foo = Heap[j];
                Heap[j/2] = Heap[j];
                Heap[j] = foo;
                j/=2;
            }
            else break;
            for(int k=1;k<=n;k++) cout << Heap[i] << " ";
            cout << endl;
        }
    }

    return 0;
}
